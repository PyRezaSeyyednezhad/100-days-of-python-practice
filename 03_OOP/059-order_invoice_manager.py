# order_invoice_manager

"""
Guide to the Exercise (Generated by ChatGPT)

Order & Invoice Manager – Advanced OOP & System Design Exercise
1. Overview
The Order & Invoice Manager is a modular, event-driven backend system designed to simulate a real-world order processing workflow.
This project focuses on:
    - Object-Oriented Design (OOP)
    - Design Patterns (Factory, Observer, Strategy)
    - Structured Logging (with rotation)
    - Domain Modeling
    - Error Handling & Transaction Integrity  
    - Clean Architecture Principles
The system manages the full lifecycle of an order — from creation to invoice generation and payment confirmation.

2. Problem Statement
Design and implement a scalable and extensible system that:
    - Allows customers to create orders containing multiple items.
    - Automatically generates invoices for confirmed orders.
    - Supports multiple payment strategies.
    - Tracks order and invoice states.
    - Notifies subscribed observers when important events occur.
    - Implements advanced logging with log rotation.
The system must follow clean architectural principles and proper separation of concerns.

3. Functional Requirements
3.1 Order Management
    - Create a new order.
    - Add multiple items to an order.
    - Calculate total order amount.
    - Cancel an order (only if not paid).
    - Retrieve order summary.
Each order must include:
    - Unique order ID
    - Customer information
    - List of items
    - Order status (Pending, Confirmed, Cancelled)
    - Total amount
    - Creation timestamp

3.2 Invoice Management
    - Generate invoice from a confirmed order.
    - Prevent duplicate invoice generation.
    - Track invoice status (Pending, Paid, Cancelled).
    - Store invoice issue timestamp.
    - Link invoice to its originating order.

3.3 Payment Handling
The system must support multiple payment strategies:
    - Credit Card
    - Digital Wallet
    - Cryptocurrency

Each payment strategy must:
    - Validate the payment
    - Return success or failure
    - Update invoice status accordingly
The payment mechanism must be implemented using the Strategy Pattern.

3.4 Event Notification (Observer Pattern)
The system must notify observers when the following events occur:
    - Order Created
    - Invoice Generated
    - Payment Completed
    - Payment Failed
    - Order Cancelled
Observers may include:
    - Logging Observer
    - Email Notification Observer
    - Analytics Observer
The Subject (Event Manager) must not depend on concrete observer implementations.

3.5 Logging (Advanced Logging Requirement)
The logging system must meet the following constraints:
1. All log levels must be written to a file.
2. Only ERROR and CRITICAL logs should be displayed in the console.
3. Log format must include:
    - Timestamp
    - Log Level
    - Module Name
    - Function Name
    - Line Number
    - Contextual ID (Order ID / Invoice ID)
    - Message
4. Log file must use size-based rotation (e.g., 5MB per file).
The logging system must be centralized and reusable.

4. Non-Functional Requirements
Code must follow OOP best practices.
    - Proper exception hierarchy must be implemented.
    - No business logic inside UI layer.
    - The system must be easily extensible.
    - No hard-coded dependencies between components.
    - Use type hints where applicable.

5. Design Constraints
You must implement the following design patterns:
    - Factory Pattern
        - Used to generate invoices dynamically.
    - Observer Pattern
        - Used for event notifications.
    - Strategy Pattern
        - Used for payment processing.
    - Optional (Bonus):
        - Singleton for logging configuration
        - Repository abstraction for persistence layer

6. Suggested Architecture
order_invoice_manager/
│
├── models/
│   ├── customer.py
│   ├── order.py
│   ├── order_item.py
│   └── invoice.py
│
├── services/
│   ├── order_service.py
│   ├── invoice_service.py
│   └── payment_service.py
│
├── patterns/
│   ├── observer.py
│   ├── factory.py
│   └── strategy.py
│
├── logging_config.py
├── exceptions.py
└── main.py

7. Expected Workflow
A typical execution scenario:
1. Create customer.
2. Create order with multiple items.
3. Confirm order.
4. Generate invoice.
5. Process payment.
6. Trigger observers.
7. Log all operations.
8. Attempt invalid operation (e.g., double payment) → raise exception.

8. Edge Cases to Handle
    - Generating invoice for cancelled order.
    - Paying an already paid invoice.
    - Creating order with empty item list.
    - Negative item price.
    - Cancelling order after payment.
    - Invalid payment method.

9. Exception Handling
Create a custom exception hierarchy:
    - BaseApplicationException
        - OrderException
        - InvoiceException
        - PaymentException
        - ValidationException
Exceptions must provide meaningful error messages and be logged properly.

10. Evaluation Criteria
Your implementation will be evaluated based on:
    - Code readability
    - Proper encapsulation
    - Pattern correctness
    - Logging quality
    - Error handling
    - Modularity
    - Extensibility
    - Clean separation of concerns


11. Learning Outcomes
After completing this exercise, you should understand:
    - How to model real-world financial workflows
    - How to decouple systems using Observer pattern
    - How to apply Strategy pattern in payment systems
    - How to implement production-grade logging
    - How to design scalable, maintainable software systems

"""

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from typing import List, Protocol, Optional

# -------------------------
# Logging (Advanced)
# -------------------------
logger = logging.getLogger("mini_bank_system")
logger.setLevel(logging.DEBUG)

formatter = logging.Formatter(
    "%(asctime)s - %(levelname)s - %(name)s - %(funcName)s - %(lineno)d - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

file_handler = logging.FileHandler("./files/order_voice_manager.log", mode="a", encoding="utf-8")
file_handler.setLevel(logging.DEBUG)
file_handler.setFormatter(formatter)

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.ERROR)
console_handler.setFormatter(formatter)

logger.addHandler(file_handler)
logger.addHandler(console_handler)

# -------------------------
# Domain Models
# -------------------------
class Order:
    def __init__(self, order_id: int, customer_name: str):
        self.order_id = order_id
        self.customer_name = customer_name
        self.items: List[str] = []
        self.total_amount: float = 0.0
        self.status: str = "Pending"
        self.created_at: datetime = datetime.now()

    def add_item(self, item_name: str, price: float) -> None:
        if price < 0:
            logger.error("Price cannot be negative.")
            raise ValueError("Price cannot be negative")
        self.items.append(item_name)
        self.total_amount += price
        logger.info("Add Item Successful.")

    def confirm_order(self) -> None:
        if not self.items:
            logger.error("Cannot confirm an order with no items")
            raise ValueError("Cannot confirm an order with no items")
        self.status = "Confirmed"
        logger.info("Confirmed")

    def cancel_order(self) -> None:
        if self.status == "Paid":
            logger.error("Cannot cancel a paid order")
            raise RuntimeError("Cannot cancel a paid order")
        self.status = "Cancelled"
        logger.info("Cancelled")

class Invoice:
    def __init__(self, invoice_id: int, order: Order):
        if order.status != "Confirmed":
            logger.error("Invoice can only be generated for confirmed orders")
            raise ValueError("Invoice can only be generated for confirmed orders")
        self.invoice_id = invoice_id
        self.order = order
        self.amount_due = order.total_amount
        self.status = "Pending"
        self.issued_at = datetime.now()
        logger.info(f"Invoice Generated. Invoice ID: {invoice_id}, Order ID: {order.order_id}, Amount Due: {self.amount_due}$")



# -------------------------
# Service
# -------------------------


# Order Service
class OrderService:
    def __init__(self):
        self.orders: List[Order] = []
        self.invoices: List[Invoice] = []
        self.next_order_id = 1
        self.next_invoice_id = 1

    def create_order(self, customer_name: str) -> Order:
        order = Order(self.next_order_id, customer_name)
        self.orders.append(order)
        logger.info(f"Order Created. Order ID: {order.order_id}, Customer: {customer_name}")
        self.next_order_id += 1
        return order

    def cancel_order(self, order_id: int) -> None:
        order = self._find_order(order_id)
        if order:
            order.cancel_order()
            logger.info(f"Order Cancelled. Order ID: {order_id}")
        else:
            logger.error(f"Order not found. Order ID: {order_id}")
            raise ValueError("Order not found")
    
    def get_order_summary(self, order_id: int) -> str:
        order = self._find_order(order_id)
        if order:
            summary = (
                f"Order ID: {order.order_id}\n"
                f"Customer: {order.customer_name}\n"
                f"Items: {', '.join(order.items)}\n"
                f"Total Amount: {order.total_amount}$\n"
                f"Status: {order.status}\n"
                f"Created At: {order.created_at.strftime('%Y-%m-%d %H:%M:%S')}"
            )
            logger.info(f"Order Summary Retrieved. Order ID: {order_id}")
            return summary
        else:
            logger.error(f"Order not found. Order ID: {order_id}")
            raise ValueError("Order not found")


# Invoice Service
class InvoiceService:
    def __init__(self):
        self.invoices: List[Invoice] = []
        self.next_invoice_id = 1

    def generate_invoice(self, order: Order) -> Invoice:
        invoice = Invoice(self.next_invoice_id, order)
        self.invoices.append(invoice)
        logger.info(f"Invoice Generated. Invoice ID: {invoice.invoice_id}, Order ID: {order.order_id}")
        self.next_invoice_id += 1
        return invoice
    
    def mark_as_paid(self, invoice_id: int) -> None:
        invoice = self._find_invoice(invoice_id)
        if invoice:
            if invoice.status == "Paid":
                logger.error(f"Invoice already paid. Invoice ID: {invoice_id}")
                raise RuntimeError("Invoice already paid")
            invoice.status = "Paid"
            logger.info(f"Invoice Marked as Paid. Invoice ID: {invoice_id}")
        else:
            logger.error(f"Invoice not found. Invoice ID: {invoice_id}")
            raise ValueError("Invoice not found")


# --------------------------
# Observers
# --------------------------

class OrderObserver(ABC):
    @abstractmethod
    def update(self, event: str) -> None:
        pass


# Subject
class OrderEventManager:
    def __init__(self):
        self._observers: List[OrderObserver] = []

    def subscribe(self, observer: OrderObserver) -> None:
        self._observers.append(observer)

    def unsubscribe(self, observer: OrderObserver) -> None:
        self._observers.remove(observer)

    def notify(self, event: str) -> None:
        for observer in self._observers:
            observer.update(event)

# Observers
class LoggerObserver:
    def update(self, event: str) -> None:
        logger.info(f"[Observer:Logger] {event}")

class EmailObserver:
    def update(self, event: str) -> None:
        logger.info(f"[Observer:Email] Email sent for event: {event}")
        
class MetricsObserver:
    def update(self, event: str) -> None:
        logger.info(f"[Observer:Metrics] Event recorded: {event}")